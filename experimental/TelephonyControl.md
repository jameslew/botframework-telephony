# Controlling Telephony and speech specific behavior
To allow speech specific functionality, the botframework SDK has extended existing APIs and implemented a new one for recording.

## Allow/disable barge in
If the user generates input to the bot (either speech or [DTMF](https://en.wikipedia.org/wiki/Dual-tone_multi-frequency_signaling)) while the bot is playing a message, the bot will stop the playback. This behavior is known as "barge in". Sometimes it is necessary, due to legal or compliance requirements, to disallow barge in for the duration of a message.

To disable barge in, the activity must have `IgnoringInput` as the input hint value. The input hint affects only the message it was applied to, not any subsequent messages.

```csharp
protected override async Task OnMembersAddedAsync(IList<ChannelAccount> membersAdded, ITurnContext<IConversationUpdateActivity> turnContext, CancellationToken cancellationToken)
{
    foreach (var member in membersAdded)
    {
        if (member.Id != turnContext.Activity.Recipient.Id)
        {
            // This message can't be interrupted by the user
            var recordingCallMessage = "This call may be recorded for quality assurance purposes.";
            await turnContext.SendActivityAsync(MessageFactory.Text(recordingCallMessage, recordingCallMessage, InputHints.IgnoringInput), cancellationToken);

            // This message can be interrupted by the user
            var supportingCallMessage = "What can I help you with today?";
            await turnContext.SendActivityAsync(MessageFactory.Text(supportingCallMessage, supportingCallMessage), cancellationToken);
        }
    }
}
```

_Note:_ In the Public Preview release, barge in only works for DTMF input (in other words, when _not_ using `InputHints.IgnoringInput`, speech input will be buffered up and sent to the bot after the end of message playback). This is a known limitation that will be resolved in the GA release.

## DTMF input

DTMF input is passed to the bot in the `Text` field of the activity object. Possible DTMF characters are digits from `0` to `9`, `*` (star) and `#` (pound). DTMF input is not localized.

Activities generated by speech and the telephone keypad are not combined. For example, saying 'fourty' and pressing &#9313; on the keypad will result in two separate activities.

It is sometimes necessary to distinguish voice from DTMF input, i.e. whether the user spoke an utterance or pressed it on the telephone keypad. 

An activity that was generated by the telephone keypad can be recognized by the presence of the DTMF entity attached to its `Entities` list. 

Example:

```csharp
protected override async Task OnMessageActivityAsync(ITurnContext<IMessageActivity> turnContext, CancellationToken cancellationToken)
{
    string response;
    if (turnContext.Activity.Entities.Any(entity => entity.Type == "DTMF"))
    {
        response = $"You have pressed DTMF button(s) {turnContext.Activity.Text}";
    }
    else
    {
        response = $"You have said {turnContext.Activity.Text}";
    }
}
```
_Note:_ In the Public Preview release, every individual key press is sent to the bot as a separate activity. The ability to "batch" multiple DTMF signals in a single activity will be added in the GA release.

## Start recording, stop recording, and attach metadata to the recording
Adapter offers “StartRecording”,“StopRecording”, and "ResumeRecording" methods, which have channel specific implementations.

StartRecording when called, starts recording the conversation and returns a recording result containing metadata about the recording.

StopRecording when called stops recording the conversation and returns a recording result containing metadata about the recording.

ResumeRecording when called, resumes recording the conversation, appending the new section of the recording to the previously started recording for this conversation, and returns a recoridng result containing metadata about the recording.

```csharp
public class RecordingResult
{
    public string RecordingId { get; set; }
    public RecordingStatus RecordingStatus { get; set; }
    public string Message { get; set; }
}

public enum RecordingStatus
{
    RecordingStarted,
    RecordingNotStarted,
    RecordingAlreadyInProgress,
    RecordingStopped
}
```

If StopRecording is never called, the recording must be stopped when the channel ends the conversation

If a recording is started for a conversation (On any storage path), recording cannot be started elsewhere. Channel should return "RecordingAlreadyInProgress" in this case, and otherwise do nothing. This will require the channel to ensure some synchronization so that no race condition is experienced by consumers of thsi API.

If StopRecording is called and there is no recording in progress, channel should return "RecordingNotStarted".

If a recording for a single conversation is stopped and started again, the recordings should be appended in storage.

Channels must return a recording id that uniquely refers to the recording at the storage path.
Channels should prefer to use conversation id as this recording id where possible.

```csharp
public class AdapterWithRecording : AdapterWithErrorHandler
{
    public AdapterWithRecording(IConfiguration configuration, ILogger<BotFrameworkHttpAdapter> logger, ConversationState conversationState = null) : base(configuration, logger, conversationState)
    {
    }

    public virtual async Task<RecordingResult> StartRecordingAsync(string StoragePath, ITurnContext turnContext, CancellationToken cancellationToken)
    {
        //Endpoint like /{conversationId}/StartRecording
        return new RecordingResult
        {
            RecordingStatus = RecordingStatus.RecordingStarted,
            Message = "Recording has started successfully."
        };
    }

    public virtual async Task<RecordingResult> StopRecordingAsync(ITurnContext turnContext, CancellationToken cancellationToken)
    {
        //Endpoint like /{conversationId}/StopRecording
        return new RecordingResult
        {
            RecordingStatus = RecordingStatus.RecordingStopped,
            Message = "Recording has stopped successfully."
        };
    }

    public virtual async Task<RecordingResult> ResumeRecordingAsync(ITurnContext turnContext, CancellationToken cancellationToken)
    {
        //Endpoint like /{conversationId}/ResumeRecording
        return new RecordingResult
        {
            RecordingStatus = RecordingStatus.RecordingStarted,
            Message = "Recording has resumed successfully."
        };
    }
}
```

Call Pattern
```csharp
protected override async Task OnMembersAddedAsync(IList<ChannelAccount> membersAdded, ITurnContext<IConversationUpdateActivity> turnContext, CancellationToken cancellationToken)
{
    foreach (var member in membersAdded)
    {
        // Greet anyone that was not the target (recipient) of this message.
        if (member.Id != turnContext.Activity.Recipient.Id)
        {
            var response = VoiceFactory.TextAndVoice($"Welcome to {CompanyName}! This call may be recorded for quality assurance purposes.");

            await turnContext.SendActivityAsync(response, cancellationToken);
            AdapterWithRecording adapterWithRecording = (AdapterWithRecording)turnContext.Adapter;

            var recordingResult = await adapterWithRecording.StartRecordingAsync("Storage1", turnContext, cancellationToken);
            if (recordingResult.RecordingStatus == RecordingStatus.RecordingNotStarted)
            {
                var recordingFailed = VoiceFactory.TextAndVoice($"Recording has failed, but your call will continue.");

                await turnContext.SendActivityAsync(recordingFailed, cancellationToken);
            }

            await Dialog.RunAsync(turnContext, ConversationState.CreateProperty<DialogState>("DialogState"), cancellationToken);
        }
    }
}
```
